class A:
    def __init__(self,x):
        self.num=x
class B:
    def __init__(self,x):
        self.num=x
class C:
    def __init__(self,x,y):
        self.a=A(x)
        sele.b=B(y)
        print(self.a.num,self.b.num)

class A:
    def fun(self): #方法和属性同名时会把方法覆盖.
        print('s') 
A.fun=1            #类可以直接定义一个变量.

class B:
    count=0
a=B()
b=B()
a.count+=10        #对象的改变不会影响类.a.count=10,b.count=0.
B.count+=10        #类的改变会影响未作修改的对象和之后定义的对象,
                   #不会影响已经改变的对象.a.count=10,b.count=10.

class a:
    def b():       #不绑定self会导致对象无法访问.
        print('sb')
a.b()              #直接使用类名可以调用.
aa=a()
aa.b()             #使用对象无法访问,因为缺少参数.

class count:
    def set(self,x,y):
        self.x=x
        self.y=y
    def pt(self):
        print(self.x,self.y)
c=count()
c.set(1,2)
count.__dict__     #会输出该类的属性,与对象无关,即c的x,y的值不会出现.
c.__dict__
{'x':1,'y':2}      #只会输出对象的属性.

del count          #删除类后,对象并不会删除.

issubclass(c1,c2)  #判断c1是否为c2的子类,返回True或False.
#一个类会被认识是自己的子类.c2可以是类组成的元组,只要c1是其中一个的子类则返回True.
#object:所有类的基类.
isinstance(o,c)    #判断对象o是否属于类c,c也可以是类组成的元组.
#当第一个参数不为对象或第二个参数不为类直接返回False.
hasattr(o,name)    #判断对象o是否含有属性name.name需要加单引号作为字符串.
getattr(o,name,default)
getattr(o,name,'属性不存在.')
#返回对象o的属性name的值,如果出错也可以设定报错的内容,带引号.
setattr(o,name,v)  #设定对象o的属性name的值,如果不存在则会创建该属性.
delattr(o,n)       #删除属性.
class aa:
    def __init__(self,size=1):
        self.size=size
    def get(self):
        return self.size
    def set(self,v):
        self.size=v
    def del(self):
        def self.size
    x=property(get,set,del)
#第一个参数是获取属性的方法,第二个是设置属性的方法,第三个是删除属性的方法(自己编写).
#好处在于修改方法时不用修改外部接口.
a=aa()                      
a.x                    #通过属性来设置属性,直接调用x来设置类的属性.
a.x=2
del a.x

class pt:              #__init__的返回值只能是None,不能return任何值.
    def __init__(self):
        print('sss')
p1=pt()                #会打印sss,因为实例化对象时会自动调用init

class upstr(str):      #str是不能修改,使用new来重写.
    def __new__(cls,s):#cls相当于init的self.
        s=s.upper()
        return str.__new__(cls,s)  
#new只能返回实例对象,基类str的new方法已经被修改,直接将修改后的s作为参数传入基类new方法.

class dd:
    def __del__(self): #当没有任何引用时才会调用del.
        print('ddd')
d1=dd()
d2=d1
d3=d1
del d3                 #不会打印,因为还有其他两个引用.
del d2                 #不会打印,还有一个引用.
del d1                 #打印ddd,没有其他引用了.
